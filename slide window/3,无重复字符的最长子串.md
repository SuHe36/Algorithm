给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

思路：我首先尝试了用二分搜索确定子字符串的长度，然后遍历，确定是否存在有效的，但是超时了，然后二分的写法还不是很熟悉。

然后看了题解，使用滑动窗口来做。也就是从头到尾遍历，当前遍历到的节点位置作为尾部end。
然后选择用start变量来保存前面出现的重复字符的最大的位置。【这句话的意思就是，前面的字符串中肯定存在重复的字符，比如字符a第二次出现时，那么它前面的最大的下标，就是第一次出现时的后一个位置。同时，前面有可能还有b出现了两次，c出现了两次，那么在这些重复出现的字符中保存一个start为最大的位置。】

最后用end-start+1就是当前的可以的构成无重复子串的长度。

代码：
```
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        n = len(s)
        start = 0
        # 用start来保存当前位置之前重复的字符的最大位置。
        ans = 0
        d = dict()
        # 用dict存储每个字符最后出现的位置，这是为了当下一次遇到这个字符时，判定这个字符可以使用的起始点为哪一个，
        # 也就是前一个字符往后后移一个位置
        for j in range(n):
            val = d[s[j]] if s[j] in d.keys() else -1
            # 当前字符s[j]在前面出现的位置，要避免重复，选择把前一个字符跳过，也就是往后移一个位置
            start = max(start, val+1)
            # 同时start要存储前面所有重复字符可以出现的位置的最大值，来避免重复
            d[s[j]] = j
            ans = max(ans, j-start+1)
        return ans

```